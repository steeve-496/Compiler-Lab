ALGORITHM:
1. Compute FOLLOW as follows:
 FOLLOW(S) contains $, If S is the starting symbol of the grammar.
 For productions AB, everything in FIRST() except goes into FOLLOW(B)
 For productions AB or ABwhere FIRST() contains , FOLLOW(B)
contains everything that is in FOLLOW(A)



PROGRAM:

#include<stdio.h>
#include<string.h>
#include<ctype.h>
int nop,m=0,p,i=0,j=0;
char prod[10][10],res[10];
void FOLLOW(char c);
void first(char c);
void result(char);
void main()
{
int i;
int choice; char c,ch;
printf("Enter the no.of productions: "); scanf("%d", &nop);
printf("enter the production string like E=E+T\n"); for(i=0;i<nop;i++)
{
printf("Enter productions Number %d : ",i+1); scanf(" %s",prod[i]);
}
do
{ m=0;
printf("Find FOLLOW of -->"); scanf(" %c",&c);
FOLLOW(c);
printf("FOLLOW(%c) = { ",c); for(i=0;i<m;i++)
printf("%c ",res[i]);
printf(" }\n");
printf("Do you want to continue(Press 1 to continue ....... )?");
scanf("%d%c",&choice,&ch);
} while(choice==1);
}
void FOLLOW(char c)
{
if(prod[0][0]==c)
result('$'); for(i=0;i<nop;i++)
{
for(j=2;j<strlen(prod[i]);j++)
{
if(prod[i][j]==c)
{
if(prod[i][j+1]!='\0')
first(prod[i][j+1]);
if(prod[i][j+1]=='\0'&&c!=prod[i][0])
FOLLOW(prod[i][0]);
}
}
}
}
void first(char c)
{
int k; if(!(isupper(c))) result(c); for(k=0;k<nop;k++)
{
if(prod[k][0]==c)
{
if(prod[k][2]=='$')
FOLLOW(prod[i][0]);
else if(islower(prod[k][2])) result(prod[k][2]);
else first(prod[k][2]);
}
}
}
void result(char c)
{
int i;
for( i=0;i<=m;i++)
if(res[i]==c)
if(res[i]==c)
return; res[m++]=c;
}




OUTPUT:

Enter the no.of productions: 8
enter the production string like E=E+T
Enter productions Number 1 : E=TX
Enter productions Number 2 : X=+TX
Enter productions Number 3 : X=$
Enter productions Number 4 : T=FY
Enter productions Number 5 : Y=*FY
Enter productions Number 6 : Y=$
Enter productions Number 7 : F=[E]
Enter productions Number 8 : i
Find FOLLOW of -->X
FOLLOW(X) = { $ ] }
Do you want to continue(Press 1 to continue ....... )?1
Find FOLLOW of -->E
FOLLOW(E) = { ] }
Do you want to continue(Press 1 to continue ....... )?1
Find FOLLOW of -->Y
FOLLOW(Y) = { + $ ] }
Do you want to continue(Press 1 to continue ....... )?1
Find FOLLOW of -->T
FOLLOW(T) = { $ ] }
Do you want to continue(Press 1 to continue ....... )?1
Find FOLLOW of -->F
FOLLOW(F) = { * + $ ] }
Do you want to continue(Press 1 to continue ....... )?2


RESULT:
Program to find the FOLLOW of a given grammar is implemented and executed
successfully.